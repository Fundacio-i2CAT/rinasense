/*
 * dtp.c
 *
 *  Created on: 11 oct. 2021
 *      Author: i2CAT
 */

#include <limits.h>

#include "portability/port.h"
#include "du.h"
#include "rina_common_port.h"
#include "rmt.h"
#include "EFCP.h"

#define TAG_DTP "[DTP]"

dtpSv_t *pxDtpStateVectorInit(void);
dtpSv_t *pxDtpStateVectorInit(void)
{
        dtpSv_t *pxDtpSv;
        pxDtpSv = pvRsMemAlloc(sizeof(*pxDtpSv));

        pxDtpSv->xNextSeqNumberToSend = 0;        // ok
        pxDtpSv->xMaxSeqNumberToSend = 0;         // ok
        pxDtpSv->xSeqNumberRolloverThreshold = 0; // ok
        pxDtpSv->xMaxSeqNumberRcvd = 0;           // ok
        pxDtpSv->stats.drop_pdus = 0;             // ok
        pxDtpSv->stats.err_pdus = 0;              // ok
        pxDtpSv->stats.tx_pdus = 0;               // ok
        pxDtpSv->stats.tx_bytes = 0;              // ok
        pxDtpSv->stats.rx_pdus = 0;               // ok
        pxDtpSv->stats.rx_bytes = 0;
        // ok
        pxDtpSv->xRexmsnCtrl = false;      // ok
        pxDtpSv->xRateBased = false;       // ok
        pxDtpSv->xWindowBased = false;     // ok
        pxDtpSv->xDrfRequired = true;      // ok
        pxDtpSv->xRateFulfiled = false;    // ok
        pxDtpSv->xMaxFlowPduSize = UINT_MAX; // ok
        pxDtpSv->xMaxFlowSduSize = UINT_MAX; // ok
        //.MPL                  = 1000,
        //.R                    = 100,
        //.A                    = 0,
        //.tr                   = 0,
        pxDtpSv->xRcvLeftWindowEdge = 0;  // ok
        pxDtpSv->xWindowClosed = false; // ok
        pxDtpSv->xDrfFlag = true;       // ok

        return pxDtpSv;
}

bool_t xDtpPduSend(struct dtp_t *pxDtp, struct rmt_t *pxRmt, struct du_t *pxDu);

bool_t xDtpPduSend(struct dtp_t *pxDtp, struct rmt_t *pxRmt, struct du_t *pxDu)
{
        struct efcpContainer_t *pxEfcpContainer;
        cepId_t destCepId;

        LOGI(TAG_DTP, "xDtpPduSend");
        /* Remote flow case */
        if (pxDu->pxPci->xSource != pxDu->pxPci->xDestination)
        {
                /*if (dtp->dtcp->sv->rendezvous_rcvr) {
                        ESP_LOGI(TAG_DTP,"Sending to RMT in RV at RCVR");
                }*/

                if (!xRmtSend(pxRmt, pxDu))
                {
                        LOGE(TAG_DTP, "Problems sending PDU to RMT");
                        return false;
                }

                return true;
        }

        /* Local flow case */
        destCepId = pxDu->pxPci->connectionId_t.xDestination;
        pxEfcpContainer = pxDtp->pxEfcp->pxEfcpContainer;
        // pxEfcpContainer = pxDtp->pxEfcp->pxEfcpContainer;
        if (!pxEfcpContainer || xDuDecap(pxDu) || !xDuIsOk(pxDu))
        { /*Decap PDU */
                LOGE(TAG_DTP, "Could not retrieve the EFCP container in"
                              "loopback operation");
                xDuDestroy(pxDu);
                return false;
        }
        if (xEfcpContainerReceive(pxEfcpContainer, destCepId, pxDu))
        {
                LOGE(TAG_DTP, "Problems sending PDU to loopback EFCP");
                return false;
        }

        return 0;
}

bool_t xDtpWrite(struct dtp_t *pxDtpInstance, struct du_t *pxDu)
{
        LOGI(TAG_DTP, "xDtpWrite");
        dtcp_t *pxDtcp;
        struct du_t *pxTempDu;
        struct dtp_ps *ps;
        seqNum_t xSn, xCsn;
        struct efcp_t *pxTempEfcp;
        int sbytes;
        uint_t uxSc;
        // timeout_t         mpl, r, a, rv;
        bool_t xStartRvTimer;

        pxTempEfcp = pxDtpInstance->pxEfcp;
        pxDtcp = pxDtpInstance->pxDtcp;

        /* Stop SenderInactivityTimer */
        /*if (rtimer_stop(&instance->timers.sender_inactivity)) {
                LOG_ERR("Failed to stop timer");
        }*/

        /*
         * FIXME: The two ways of carrying out flow control
         * could exist at once, thus reconciliation should be
         * the first and default case if both are present.
         */

        /* FIXME: from now on, this should be done for each user data
         * generated by Delimiting *
         */

        /* Step 2: Sequencing */
        /*
         * Incrementing here means the PDU cannot
         * be just thrown away from this point onwards
         */
        /* Probably needs to be revised */

        sbytes = xDuLen(pxDu);
        sbytes = pxDu->pxNetworkBuffer->xDataLength;

        LOGI(TAG_DTP, "Calling DUEncap");
        LOGI(TAG_DTP, "Sbytes: %d", sbytes);
        if (!xDuEncap(pxDu, PDU_TYPE_DT))
        {
                LOGE(TAG_DTP, "Could not encap PDU");
                xDuDestroy(pxDu);
                return false;
        }

        xCsn = ++pxDtpInstance->pxDtpStateVector->xNextSeqNumberToSend;

        pxDu->pxPci->ucVersion = 0x01;
        pxDu->pxPci->connectionId_t.xSource = pxTempEfcp->pxConnection->xSourceCepId;
        pxDu->pxPci->connectionId_t.xDestination = pxTempEfcp->pxConnection->xDestinationCepId;
        pxDu->pxPci->connectionId_t.xQosId = pxTempEfcp->pxConnection->xQosId;
        pxDu->pxPci->xDestination = pxTempEfcp->pxConnection->xDestinationAddress;
        pxDu->pxPci->xSource = pxTempEfcp->pxConnection->xSourceAddress;

        pxDu->pxPci->xFlags = 0;
        pxDu->pxPci->xType = PDU_TYPE_DT;
        pxDu->pxPci->xPduLen = pxDu->pxNetworkBuffer->xDataLength;
        pxDu->pxPci->xSequenceNumber = xCsn;
#if 0
        LOGI(TAG_DTP, "------------ PCI DT-----------");
        LOGI(TAG_DTP, "PCI Version: 0x%04x", pxDu->pxPci->ucVersion);
        LOGI(TAG_DTP, "PCI SourceAddress: 0x%04x", pxDu->pxPci->xSource);
        LOGI(TAG_DTP, "PCI DestinationAddress: 0x%04x", pxDu->pxPci->xDestination);
        LOGI(TAG_DTP, "PCI QoS: 0x%04x", pxDu->pxPci->connectionId_t.xQosId);
        LOGI(TAG_DTP, "PCI CEP Source: 0x%04x", pxDu->pxPci->connectionId_t.xSource);
        LOGI(TAG_DTP, "PCI CEP Destination: 0x%04x", pxDu->pxPci->connectionId_t.xDestination);
        LOGI(TAG_DTP, "PCI FLAG: 0x%04x", pxDu->pxPci->xFlags);
        LOGI(TAG_DTP, "PCI Type: 0x%04x", pxDu->pxPci->xType);
        LOGI(TAG_DTP, "PCI SequenceNumber: 0x%08x", pxDu->pxPci->xSequenceNumber);
        LOGI(TAG_DTP, "PCI xPDULEN: 0x%04x", pxDu->pxPci->xPduLen);
#endif
        if (!xPciIsOk(pxDu->pxPci))
        {
                LOGE(TAG_DTP, "PCI is not ok");
                xDuDestroy(pxDu);
                return false;
        }

        // sn = dtcp->sv->snd_lft_win;

        if (pxDtpInstance->pxDtpStateVector->xDrfFlag) //||
                                                       //((sn == (csn - 1)) && instance->sv->rexmsn_ctrl))
        {
                pduFlags_t xPciFlags;
                xPciFlags = pxDu->pxPci->xFlags;
                xPciFlags |= PDU_FLAGS_DATA_RUN;
                pxDu->pxPci->xFlags = xPciFlags;
                LOGI(TAG_DTP, "PCI FLAG: 0x%04x", pxDu->pxPci->xFlags);
        }
#if 0
        LOG_DBG("DTP Sending PDU %u (CPU: %d)", csn, smp_processor_id());
        mpl = instance->sv->MPL;
        r = instance->sv->R;
        a = instance->sv->A;
        spin_unlock_bh(&instance->sv_lock);

        if (dtcp) {
                rcu_read_lock();
                ps = container_of(rcu_dereference(instance->base.ps),
                                  struct dtp_ps, base);
                if (instance->sv->window_based || instance->sv->rate_based) {
			/* NOTE: Might close window */
			if (window_is_closed(instance,
						dtcp,
						csn,
						ps)) {
				if (ps->closed_window(ps, du)) {
					LOG_ERR("Problems with the closed window policy");
					goto stats_err_exit;
				}
				rcu_read_unlock();

				/* Check if rendezvous PDU needs to be sent*/
				start_rv_timer = false;
				spin_lock_bh(&instance->sv_lock);

				/* If there is rtx control and PDUs at the rtxQ
				 * don't enter the rendezvous state (DTCP will keep
				 * retransmitting the PDUs until acked or the
				 * retransmission timeout fires)
				 */
				if (instance->sv->rexmsn_ctrl &&
						rtxq_size(instance->rtxq) > 0) {
					LOG_DBG("Window is closed but there are PDUs at the RTXQ");
					spin_unlock_bh(&instance->sv_lock);
					return 0;
				}

				/* Else, check if rendezvous PDU needs to be sent */
				if (!instance->dtcp->sv->rendezvous_sndr) {
					instance->dtcp->sv->rendezvous_sndr = true;

					LOG_DBG("RV at the sender %u (CPU: %d)", csn, smp_processor_id());

					/* Start rendezvous timer, wait for Tr to fire */
					start_rv_timer = true;
					rv = jiffies_to_msecs(instance->sv->tr);
				}
				spin_unlock_bh(&instance->sv_lock);

				if (start_rv_timer) {
					LOG_DBG("Window is closed. SND LWE: %u | SND RWE: %u | TR: %u",
							instance->dtcp->sv->snd_lft_win,
							instance->dtcp->sv->snd_rt_wind_edge,
							instance->sv->tr);
					/* Send rendezvous PDU and start time */
					rtimer_start(&instance->timers.rendezvous, rv);
				}

				return 0;
			}
			if(instance->sv->rate_based) {
				spin_lock_bh(&instance->sv_lock);
				sc = dtcp->sv->pdus_sent_in_time_unit;
				if(sbytes >= 0) {
					if (sbytes + sc >= dtcp->sv->sndr_rate)
						dtcp->sv->pdus_sent_in_time_unit =
								dtcp->sv->sndr_rate;
					else
						dtcp->sv->pdus_sent_in_time_unit =
								dtcp->sv->pdus_sent_in_time_unit + sbytes;
				}
				spin_unlock_bh(&instance->sv_lock);
			}
                }
                if (instance->sv->rexmsn_ctrl) {
                        cdu = du_dup_ni(du);
                        if (!cdu) {
                                LOG_ERR("Failed to copy PDU. PDU type: %d",
                                	 pci_type(&du->pci));
                                goto pdu_stats_err_exit;
                        }

                        if (rtxq_push_ni(instance->rtxq, cdu)) {
                                LOG_ERR("Couldn't push to rtxq");
                                goto pdu_stats_err_exit;
                        }
                } else if (instance->rttq) {
                	if (rttq_push(instance->rttq, csn)) {
                		LOG_ERR("Failed to push SN to RTT queue");
                	}
                }

                if (ps->transmission_control(ps, du)) {
                        LOG_ERR("Problems with transmission control");
                        goto stats_err_exit;
                }

                rcu_read_unlock();
                spin_lock_bh(&instance->sv_lock);
                stats_inc_bytes(tx, instance->sv, sbytes);
                spin_unlock_bh(&instance->sv_lock);

                /* Start SenderInactivityTimer */
                if (rtimer_restart(&instance->timers.sender_inactivity,
                                   3 * (mpl + r + a ))) {
                        LOG_ERR("Failed to start sender_inactiviy timer");
                        goto stats_nounlock_err_exit;
                        return -1;
                }

                return 0;
        }
#endif
        if (!xDtpPduSend(pxDtpInstance,
                        pxDtpInstance->pxRmt,
                        pxDu))
                return false;
        // spin_lock_bh(&instance->sv_lock);
        // stats_inc_bytes(tx, pxDtpInstance->pxDtpStateVector, sbytes);
        // spin_unlock_bh(&instance->sv_lock);
        return true;
}

static inline bool_t xDtpPduPost(struct dtp_t *pxDtpInstance, struct du_t *pxDu)
{
        struct efcp_t *pxEfcp;

        pxEfcp = pxDtpInstance->pxEfcp;

        if (!xEfcpEnqueue(pxEfcp, pxEfcp->pxConnection->xPortId, pxDu))
        {
                LOGE(TAG_DTP, "Could not enqueue SDU to EFCP");
                return false;
        }

        LOGI(TAG_DTP, "DTP enqueued to upper IPCP");
        return true;
}

bool_t xDtpReceive(struct dtp_t *pxDtpInstance, struct du_t *pxDu)
{
        // struct dtp_ps *  ps;
        dtcp_t *pxDtcp;
        struct dtcp_ps *dtcp_ps;
        seqNum_t xSeqNum;
        // timeout_t        a, r, mpl;
        seqNum_t xLWE;
        bool_t xInOrder;
        bool_t xRtxCtrl = false;
        seqNum_t xMaxSduGap;
        int sbytes;
        struct efcp_t *pxEfcp = 0;

        LOGI(TAG_DTP, "DTP receive started...");

        pxDtcp = pxDtpInstance->pxDtcp;
        pxEfcp = pxDtpInstance->pxEfcp;

        xLWE = pxDtpInstance->pxDtpStateVector->xRcvLeftWindowEdge;

        xInOrder = true; // HardCode for completing the phase one
        xMaxSduGap = pxDtpInstance->pxDtpCfg->xMaxSduGap;

        xSeqNum = pxDu->pxPci->xSequenceNumber;
        sbytes = xDuDataLen(pxDu);

        if (pxDtpInstance->pxDtpStateVector->xDrfRequired)
        {

                LOGD(TAG_DTP, "PCI FLAG: 0x%04x", pxDu->pxPci->xFlags);

                if (pxDu->pxPci->xFlags & PDU_FLAGS_DATA_RUN)
                {
                        LOGI(TAG_DTP, "Data Run Flag");

                        pxDtpInstance->pxDtpStateVector->xDrfRequired = false;
                        pxDtpInstance->pxDtpStateVector->xRcvLeftWindowEdge = xSeqNum;

                        // dtp_send_pending_ctrl_pdus(instance); // check this
                        xDtpPduPost(pxDtpInstance, pxDu); // check this
                                                          // stats_inc_bytes(rx, instance->sv, sbytes);

                        return true;
                }

                /* LOGE(TAG_DTP, "Expecting DRF but not present, dropping PDU %d...", */
                /*      xSeqNum); */
                xDtpPduPost(pxDtpInstance, pxDu);
                // stats_inc(drop, instance->sv);
                // spin_unlock_bh(&instance->sv_lock);

                return true;
        }

        /*
         * NOTE:
         *   no need to check presence of in_order or dtcp because in case
         *   they are not, LWE is not updated and always 0
         */
        if (xSeqNum <= xLWE)
        {
                /* Duplicate PDU or flow control overrun */
                LOGE(TAG_DTP, "Duplicate PDU or flow control overrun.SN: %u, LWE:%u",
                     xSeqNum, xLWE);
                // stats_inc(drop, instance->sv);

                // spin_unlock_bh(&instance->sv_lock);

                xDuDestroy(pxDu);

                return 0;
        }

        xLWE = pxDtpInstance->pxDtpStateVector->xRcvLeftWindowEdge;

        LOGI(TAG_DTP, "DTP receive LWE: %u", xLWE);
        if (xSeqNum == xLWE + 1)
        {
                pxDtpInstance->pxDtpStateVector->xRcvLeftWindowEdge = xSeqNum;

                xLWE = xSeqNum;
        }

        xDtpPduPost(pxDtpInstance, pxDu);

        LOGI(TAG_DTP, "DTP receive ended...");

        return true;
}

bool_t xDtpDestroy(struct dtp_t *pxInstance)
{
        dtcp_t *pxDtcp = NULL;
        // struct cwq * cwq = NULL;
        // struct rtxq * rtxq = NULL;
        // struct rttq * rttq = NULL;
        bool_t ret = true;

        if (!pxInstance)
                return false;

        if (pxInstance->pxDtcp)
        {
                pxDtcp = pxInstance->pxDtcp;
                pxInstance->pxDtcp = NULL; /* Useful */
        }

        LOGI(TAG_DTP, "DTP %pK destroyed successfully", pxInstance);

        // robject_del(&instance->robj);
        vRsMemFree(pxInstance);

        return true;
}

struct dtp_t *pxDtpCreate(struct efcp_t *pxEfcp,
                          struct rmt_t *pxRmt,
                          dtpConfig_t *pxDtpCfg)
{
        struct dtp_t *pxDtp;
        string_t *psName;
        dtpSv_t *pxDtpSv;

        if (!pxEfcp)
        {
                LOGE(TAG_DTP, "No EFCP passed, bailing out");
                return NULL;
        }

        if (!pxDtpCfg)
        {
                LOGE(TAG_DTP, "No DTP conf passed, bailing out");
                return NULL;
        }

        if (!pxRmt)
        {
                LOGE(TAG_DTP, "No RMT passed, bailing out");
                return NULL;
        }

        pxDtp = pvRsMemAlloc(sizeof(*pxDtp));
        if (!pxDtp)
        {
                LOGE(TAG_DTP, "Cannot create DTP instance");
                return NULL;
        }

        pxDtp->pxEfcp = pxEfcp;

        /*if (robject_init_and_add(&dtp->robj,
                                 &dtp_rtype,
                                 parent,
                                 "dtp")) {
                dtp_destroy(dtp);
                return NULL;
        }*/

        pxDtpSv = pvRsMemAlloc(sizeof(*pxDtpSv));
        pxDtp->pxDtpStateVector = pxDtpStateVectorInit();
        if (!pxDtp->pxDtpStateVector)
        {
                LOGE(TAG_DTP, "Cannot create DTP state-vector");
                xDtpDestroy(pxDtp);
                return NULL;
        }

#ifdef __FREERTOS__
        heap_caps_check_integrity(MALLOC_CAP_DEFAULT, true);
#endif
        //*pxDtp->pxDtpStateVector = default_sv;
        /* FIXME: fixups to the state-vector should be placed here */

        // spin_lock_init(&dtp->sv_lock);
#ifdef __FREERTOS__
        heap_caps_check_integrity(MALLOC_CAP_DEFAULT, true);
#endif
        pxDtp->pxDtpCfg = pxDtpCfg;
        pxDtp->pxRmt = pxRmt;
        // dtp->rttq = NULL;
        // dtp->rtxq = NULL;
        // dtp->seqq = squeue_create(dtp);
#if 0
        if (!dtp->seqq) {
                LOG_ERR("Could not create Sequencing queue");
                dtp_destroy(dtp);
                return NULL;
        }

        rtimer_init(tf_sender_inactivity, &dtp->timers.sender_inactivity, dtp);
        rtimer_init(tf_receiver_inactivity, &dtp->timers.receiver_inactivity, dtp);
        rtimer_init(tf_a, &dtp->timers.a, dtp);
        rtimer_init(tf_rate_window, &dtp->timers.rate_window, dtp);
        rtimer_init(tf_rendezvous, &dtp->timers.rendezvous, dtp);

        dtp->to_post = ringq_create(TO_POST_LENGTH);
        if (!dtp->to_post) {
                LOG_ERR("Unable to create to_post queue; bailing out");
               dtp_destroy(dtp);
               return NULL;
        }
        dtp->to_send = ringq_create(TO_SEND_LENGTH);
        if (!dtp->to_send) {
               LOG_ERR("Unable to create to_send queue; bailing out");
               dtp_destroy(dtp);
               return NULL;
        }

        rina_component_init(&dtp->base);

        ps_name = (string_t *) policy_name(dtp_conf_ps_get(dtp_cfg));
        if (!ps_name || !strcmp(ps_name, ""))
                ps_name = RINA_PS_DEFAULT_NAME;

        if (dtp_select_policy_set(dtp, "", ps_name)) {
                LOGE(TAG_DTP,"Could not load DTP PS %s", ps_name);
                xDtpDestroy(pxDtp);
                return NULL;
        }



        if (dtp_initial_sequence_number(dtp)) {
                LOGE(TAG_DTP,"Could not create Sequencing queue");
                xDtpDestroy(pxDtp);
                return NULL;
        }

        //spin_lock_init(&dtp->lock);

#endif

        return pxDtp;
}
